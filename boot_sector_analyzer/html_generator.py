"""HTML report generation for boot sector analysis results."""

import logging
from html import escape as html_escape
from datetime import datetime
from typing import List, Dict, Any

from . import __version__
from .models import AnalysisResult, ThreatLevel, DisassemblyResult, Instruction

logger = logging.getLogger(__name__)


class HTMLGenerator:
    """Generates HTML reports with embedded CSS styling and interactive elements."""
    
    def __init__(self):
        """Initialize HTML generator."""
        pass
    
    def create_html_document(self, analysis_result: AnalysisResult) -> str:
        """
        Create complete HTML document with DOCTYPE and metadata.
        
        Args:
            analysis_result: Complete analysis results
            
        Returns:
            Self-contained HTML document string
        """
        # Generate HTML content sections
        css_styles = self.embed_css_styles()
        threat_badge = self.format_threat_level_badge(analysis_result.security_analysis.threat_level)
        table_of_contents = self.create_table_of_contents()
        
        # Format disassembly (handles both present and empty boot code cases)
        assembly_html = self.format_assembly_syntax_highlighting(analysis_result.disassembly)
        
        # Format hexdump with colors and partition-specific coloring
        mbr_structure = None
        try:
            from .mbr_decoder import MBRDecoder
            decoder = MBRDecoder()
            mbr_structure = decoder.parse_mbr(analysis_result.hexdump.raw_data)
        except Exception as e:
            logger.debug(f"Could not parse MBR for partition coloring: {e}")
        
        hexdump_html = self.format_hexdump_with_colors(analysis_result.hexdump.raw_data, mbr_structure)
        
        # Generate threat intelligence section
        threat_intelligence_html = self._generate_threat_intelligence_section_html(analysis_result)
        
        # Get current timestamp and version
        generation_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        analyzer_version = f"v{__version__}"  # Current version
        
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Boot Sector Analyzer {analyzer_version}">
    <meta name="generated" content="{generation_time}">
    <title>Boot Sector Analysis Report - {html_escape(analysis_result.source)}</title>
    <style>
{css_styles}
    </style>
</head>
<body>
    <div class="container">
        <header class="report-header">
            <h1>Boot Sector Analysis Report</h1>
            <div class="report-meta">
                <p><strong>Source:</strong> {html_escape(analysis_result.source)}</p>
                <p><strong>Analysis Time:</strong> {analysis_result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p><strong>Generated:</strong> {generation_time}</p>
                <p><strong>Analyzer Version:</strong> {analyzer_version}</p>
            </div>
            <div class="threat-level">
                {threat_badge}
            </div>
        </header>
        
        {table_of_contents}
        
        <main class="report-content">
            {self._generate_structure_section_html(analysis_result)}
            {self._generate_content_section_html(analysis_result)}
            {self._generate_security_section_html(analysis_result)}
            {threat_intelligence_html}
            {self._generate_vbr_analysis_section_html(analysis_result)}
            {self._generate_disassembly_section_html(assembly_html)}
            {self._generate_hexdump_section_html(hexdump_html)}
            {self._generate_summary_section_html(analysis_result)}
        </main>
        
        <footer class="report-footer">
            <p>Generated by Boot Sector Analyzer {analyzer_version} on {generation_time}</p>
        </footer>
    </div>
</body>
</html>"""
        
        return html_content
    
    def embed_css_styles(self) -> str:
        """
        Generate embedded CSS for styling and responsive design.
        
        Returns:
            CSS styles as string
        """
        return """
/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    min-height: 100vh;
}

/* Header styles */
.report-header {
    border-bottom: 3px solid #007acc;
    padding-bottom: 20px;
    margin-bottom: 30px;
}

.report-header h1 {
    color: #007acc;
    font-size: 2.5em;
    margin-bottom: 15px;
}

.report-meta {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 15px;
}

.report-meta p {
    margin-bottom: 5px;
}

/* Threat level badges */
.threat-level {
    text-align: center;
    margin: 20px 0;
}

.threat-badge {
    display: inline-block;
    padding: 10px 20px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 1.2em;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.threat-low {
    background-color: #28a745;
    color: white;
}

.threat-medium {
    background-color: #ffc107;
    color: #212529;
}

.threat-high {
    background-color: #dc3545;
    color: white;
}

.threat-critical {
    background-color: #6f0000;
    color: white;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

/* Table of contents */
.table-of-contents {
    background-color: #e9ecef;
    padding: 20px;
    border-radius: 5px;
    margin-bottom: 30px;
}

.table-of-contents h2 {
    margin-bottom: 15px;
    color: #495057;
}

.toc-list {
    list-style: none;
    columns: 2;
    column-gap: 30px;
}

.toc-list li {
    margin-bottom: 8px;
    break-inside: avoid;
}

.toc-list a {
    color: #007acc;
    text-decoration: none;
    padding: 5px 10px;
    display: block;
    border-radius: 3px;
    transition: background-color 0.2s;
}

.toc-list a:hover {
    background-color: #007acc;
    color: white;
}

/* Section styles */
.section {
    margin-bottom: 40px;
    padding: 20px;
    border: 1px solid #dee2e6;
    border-radius: 5px;
    background-color: #fff;
}

.section h2 {
    color: #007acc;
    border-bottom: 2px solid #007acc;
    padding-bottom: 10px;
    margin-bottom: 20px;
}

.section h3 {
    color: #495057;
    margin-top: 20px;
    margin-bottom: 10px;
}

/* Monospace formatting for technical data */
.monospace {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #f8f9fa;
    padding: 2px 4px;
    border-radius: 3px;
    font-size: 0.9em;
}

.code-block {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 5px;
    padding: 15px;
    overflow-x: auto;
    white-space: pre;
    line-height: 1.4;
}

/* Hash values - copyable */
.hash-value {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #f8f9fa;
    padding: 5px 8px;
    border-radius: 3px;
    border: 1px solid #dee2e6;
    cursor: text;
    user-select: all;
    word-break: break-all;
}

/* Assembly syntax highlighting */
.assembly-code {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #f8f9fa; /* Light background instead of dark theme */
    color: #212529; /* Dark text for better contrast */
    padding: 20px;
    border-radius: 5px;
    border: 1px solid #dee2e6; /* Subtle border for professional appearance */
    overflow-x: auto;
    line-height: 1.4;
}

.asm-instruction {
    color: #0066cc; /* Professional blue */
    font-weight: 500; /* Medium font weight */
}

.asm-register {
    color: #228b22; /* Forest green for better readability */
}

.asm-immediate {
    color: #d2691e; /* Chocolate orange */
}

.asm-address {
    color: #dc143c; /* Crimson red */
}

.asm-comment {
    color: #6a737d; /* Muted gray to reduce visual noise */
    font-style: italic;
}

/* Fixed-width hexdump table */
.hexdump-table {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    border-collapse: collapse;
    width: 100%;
    font-size: 0.85em;
    background-color: #fff;
    table-layout: fixed; /* Prevent column width variations */
}

.hexdump-table th,
.hexdump-table td {
    padding: 4px 6px;
    text-align: center;
    border: 1px solid #dee2e6;
}

.hexdump-table th {
    background-color: #495057;
    color: white;
    font-weight: bold;
}

/* Fixed offset column width for consistency */
.hexdump-table .offset {
    width: 80px; /* Fixed 80px width for consistency */
    background-color: #f8f9fa;
    font-weight: bold;
    text-align: right;
    padding: 4px 8px;
}

/* Fixed hex byte column widths for uniform spacing */
.hexdump-table td:not(.offset):not(.ascii) {
    width: 30px; /* Fixed 30px width each for uniform spacing */
    text-align: center;
    padding: 4px 2px;
}

.hexdump-table th:not(.offset):not(.ascii) {
    width: 30px; /* Fixed 30px width for header hex columns */
    text-align: center;
}

/* Fixed ASCII column width for proper alignment */
.hexdump-table .ascii {
    width: 120px; /* Fixed 120px width for proper alignment */
    text-align: left;
    background-color: #f8f9fa;
    padding: 4px 8px;
}

/* MBR section highlighting */
.mbr-boot-code {
    background-color: #cce5ff !important; /* Light blue */
}

.mbr-disk-signature {
    background-color: #fff2cc !important; /* Light yellow */
}

.mbr-partition-table {
    background-color: #d4edda !important; /* Light green */
}

/* Individual partition colors */
.mbr-partition-1 {
    background-color: #FFE6E6 !important; /* Light red */
}

.mbr-partition-2 {
    background-color: #E6F3FF !important; /* Light blue */
}

.mbr-partition-3 {
    background-color: #E6FFE6 !important; /* Light green */
}

.mbr-partition-4 {
    background-color: #FFF0E6 !important; /* Light orange */
}

.mbr-partition-empty {
    background-color: #F5F5F5 !important; /* Light gray */
}

.mbr-boot-signature {
    background-color: #f8d7da !important; /* Light red */
}

/* Lists and data display */
.data-list {
    list-style: none;
    padding-left: 0;
}

.data-list li {
    padding: 8px 0;
    border-bottom: 1px solid #e9ecef;
}

.data-list li:last-child {
    border-bottom: none;
}

.threat-item {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 10px;
}

.threat-item .threat-name {
    font-weight: bold;
    color: #721c24;
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        padding: 10px;
    }
    
    .report-header h1 {
        font-size: 2em;
    }
    
    .toc-list {
        columns: 1;
    }
    
    .hexdump-table {
        font-size: 0.7em;
    }
    
    .hexdump-table th,
    .hexdump-table td {
        padding: 2px 3px;
    }
}

@media (max-width: 480px) {
    .report-header h1 {
        font-size: 1.5em;
    }
    
    .threat-badge {
        font-size: 1em;
        padding: 8px 15px;
    }
    
    .section {
        padding: 15px;
    }
}

/* Print styles */
@media print {
    body {
        background-color: white;
    }
    
    .container {
        box-shadow: none;
        max-width: none;
    }
    
    .threat-critical {
        animation: none;
    }
    
    .toc-list a {
        color: #000;
    }
}

/* VirusTotal Enhanced Display Styles */
.virustotal-summary {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    margin: 15px 0;
}

.detection-summary {
    text-align: center;
    margin-bottom: 20px;
}

.detection-count {
    font-size: 2em;
    font-weight: bold;
    margin-right: 10px;
}

.detection-ratio-low {
    color: #28a745;
}

.detection-ratio-medium {
    color: #fd7e14;
}

.detection-ratio-high {
    color: #dc3545;
}

.detection-label {
    font-size: 1.2em;
    color: #6c757d;
    margin-right: 10px;
}

.detection-ratio {
    font-size: 1.1em;
    font-weight: bold;
}

/* Enhanced status indicators for negative results */
.clean-status {
    background-color: #d4edda !important;
    border: 2px solid #28a745 !important;
    color: #155724 !important;
    font-size: 1.3em;
}

.low-risk-status {
    background-color: #fff3cd !important;
    border: 2px solid #fd7e14 !important;
    color: #856404 !important;
    font-size: 1.3em;
}

.moderate-risk-status {
    background-color: #fff3cd !important;
    border: 2px solid #fd7e14 !important;
    color: #856404 !important;
    font-size: 1.3em;
}

.high-risk-status {
    background-color: #f8d7da !important;
    border: 2px solid #dc3545 !important;
    color: #721c24 !important;
    font-size: 1.3em;
}

.negative-result-message {
    font-size: 1.1em;
    text-align: center;
}

.scan-statistics {
    margin-top: 20px;
}

.scan-statistics h4 {
    color: #495057;
    margin-bottom: 15px;
    border-bottom: 2px solid #dee2e6;
    padding-bottom: 5px;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    margin-bottom: 15px;
}

.stat-item {
    background-color: white;
    border: 1px solid #dee2e6;
    border-radius: 5px;
    padding: 10px;
    text-align: center;
}

.stat-item.malicious {
    border-left: 4px solid #dc3545;
}

.stat-item.suspicious {
    border-left: 4px solid #fd7e14;
}

.stat-item.undetected {
    border-left: 4px solid #28a745;
}

.stat-item.harmless {
    border-left: 4px solid #6c757d;
}

.stat-item.timeout,
.stat-item.failure {
    border-left: 4px solid #ffc107;
}

.stat-label {
    display: block;
    font-size: 0.9em;
    color: #6c757d;
    margin-bottom: 5px;
}

.stat-value {
    display: block;
    font-size: 1.5em;
    font-weight: bold;
    color: #495057;
}

.detection-details {
    margin-top: 20px;
}

.detection-details-expandable {
    border: 1px solid #dee2e6;
    border-radius: 5px;
    margin-top: 15px;
}

.detection-details-expandable summary {
    background-color: #f8f9fa;
    padding: 15px;
    cursor: pointer;
    border-radius: 5px 5px 0 0;
    font-weight: bold;
}

.detection-details-expandable summary:hover {
    background-color: #e9ecef;
}

.detection-details-expandable[open] summary {
    border-bottom: 1px solid #dee2e6;
    border-radius: 5px 5px 0 0;
}

.engine-results {
    padding: 15px;
    max-height: 400px;
    overflow-y: auto;
}

.engine-result {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    margin-bottom: 5px;
    border-radius: 4px;
    border-left: 4px solid #dee2e6;
}

.engine-result.category-malicious {
    background-color: #f8d7da;
    border-left-color: #dc3545;
}

.engine-result.category-suspicious {
    background-color: #fff3cd;
    border-left-color: #fd7e14;
}

.engine-result.category-undetected {
    background-color: #d1ecf1;
    border-left-color: #17a2b8;
}

.engine-result.category-harmless {
    background-color: #d4edda;
    border-left-color: #28a745;
}

.engine-name {
    font-weight: bold;
    color: #495057;
    flex: 0 0 150px;
}

.detection-result {
    flex: 1;
    margin: 0 10px;
    color: #212529;
}

.detection-category {
    font-size: 0.9em;
    color: #6c757d;
    flex: 0 0 100px;
    text-align: right;
}

.engine-version {
    font-size: 0.8em;
    color: #6c757d;
    font-style: italic;
}

.more-results {
    text-align: center;
    padding: 10px;
    color: #6c757d;
    font-style: italic;
}

/* Responsive adjustments for VirusTotal display */
@media (max-width: 768px) {
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .engine-result {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .engine-name,
    .detection-category {
        flex: none;
        margin-bottom: 5px;
    }
    
    .detection-result {
        margin: 5px 0;
    }
}
"""
    
    def format_threat_level_badge(self, threat_level: ThreatLevel) -> str:
        """
        Create color-coded threat level badge.
        
        Args:
            threat_level: Threat level to format
            
        Returns:
            HTML for threat level badge
        """
        level_classes = {
            ThreatLevel.LOW: "threat-low",
            ThreatLevel.MEDIUM: "threat-medium", 
            ThreatLevel.HIGH: "threat-high",
            ThreatLevel.CRITICAL: "threat-critical"
        }
        
        level_icons = {
            ThreatLevel.LOW: "‚úÖ",
            ThreatLevel.MEDIUM: "‚ö†Ô∏è",
            ThreatLevel.HIGH: "üö®", 
            ThreatLevel.CRITICAL: "üî¥"
        }
        
        css_class = level_classes.get(threat_level, "threat-low")
        icon = level_icons.get(threat_level, "‚ùì")
        
        return f'<div class="threat-badge {css_class}">{icon} {threat_level.value}</div>'
    
    def format_assembly_syntax_highlighting(self, disassembly) -> str:
        """
        Apply syntax highlighting to assembly code.
        
        Args:
            disassembly: Disassembly results to format, or None if no boot code
            
        Returns:
            HTML with syntax-highlighted assembly code or empty boot code message
        """
        if disassembly is None:
            return '<div class="assembly-code"><p><em>No boot code present (all zeros)</em></p></div>'
        
        if not disassembly.instructions:
            return '<div class="assembly-code"><p><em>No assembly instructions available</em></p></div>'
        
        html_lines = []
        
        for instruction in disassembly.instructions:
            # Format address
            addr_html = f'<span class="asm-address">{instruction.address:04X}</span>'
            
            # Format instruction bytes
            bytes_str = ' '.join(f'{b:02X}' for b in instruction.bytes)
            bytes_html = f'<span class="monospace">{bytes_str:12}</span>'
            
            # Format mnemonic (instruction)
            mnemonic_html = f'<span class="asm-instruction">{instruction.mnemonic}</span>'
            
            # Format operands with syntax highlighting
            operands_html = self._highlight_operands(instruction.operands)
            
            # Format comment if present
            comment_html = ""
            if instruction.comment:
                comment_html = f' <span class="asm-comment">; {html_escape(instruction.comment)}</span>'
            
            # Combine into line
            line = f'{addr_html}:  {bytes_html}  {mnemonic_html} {operands_html}{comment_html}'
            html_lines.append(line)
        
        # Add invalid instructions if any
        for invalid in disassembly.invalid_instructions:
            addr_html = f'<span class="asm-address">{invalid.address:04X}</span>'
            bytes_str = ' '.join(f'{b:02X}' for b in invalid.bytes)
            bytes_html = f'<span class="monospace">{bytes_str:12}</span>'
            reason_html = f'<span class="asm-comment">; Invalid: {html_escape(invalid.reason)}</span>'
            
            line = f'{addr_html}:  {bytes_html}  {reason_html}'
            html_lines.append(line)
        
        return f'<div class="assembly-code">{"<br>".join(html_lines)}</div>'
    
    def _highlight_operands(self, operands: str) -> str:
        """
        Apply syntax highlighting to instruction operands.
        
        Args:
            operands: Operand string to highlight
            
        Returns:
            HTML with highlighted operands
        """
        if not operands:
            return ""
        
        # Simple regex-based highlighting
        import re
        
        # Escape HTML first
        operands = html_escape(operands)
        
        # Highlight registers (common x86 registers)
        register_pattern = r'\b(ax|bx|cx|dx|si|di|sp|bp|al|ah|bl|bh|cl|ch|dl|dh|eax|ebx|ecx|edx|esi|edi|esp|ebp|cs|ds|es|fs|gs|ss)\b'
        operands = re.sub(register_pattern, r'<span class="asm-register">\1</span>', operands, flags=re.IGNORECASE)
        
        # Highlight immediate values (hex numbers)
        immediate_pattern = r'\b0x[0-9a-fA-F]+\b|\b[0-9]+h?\b'
        operands = re.sub(immediate_pattern, r'<span class="asm-immediate">\g<0></span>', operands)
        
        # Highlight memory addresses (brackets)
        address_pattern = r'\[([^\]]+)\]'
        operands = re.sub(address_pattern, r'[<span class="asm-address">\1</span>]', operands)
        
        return operands
    
    def create_table_of_contents(self) -> str:
        """
        Generate table of contents with anchor links.
        
        Returns:
            HTML for table of contents
        """
        return """
        <nav class="table-of-contents">
            <h2>Table of Contents</h2>
            <ul class="toc-list">
                <li><a href="#structure-analysis">Structure Analysis</a></li>
                <li><a href="#content-analysis">Content Analysis</a></li>
                <li><a href="#security-analysis">Security Analysis</a></li>
                <li><a href="#threat-intelligence">Threat Intelligence</a></li>
                <li><a href="#vbr-analysis">VBR Analysis</a></li>
                <li><a href="#disassembly">Boot Code Disassembly</a></li>
                <li><a href="#hexdump">Hexdump</a></li>
                <li><a href="#summary">Summary</a></li>
            </ul>
        </nav>
        """
    
    def format_hexdump_with_colors(self, boot_sector: bytes, mbr_structure=None) -> str:
        """
        Create color-coded hexdump table for MBR sections with individual partition coloring.
        
        Args:
            boot_sector: 512-byte boot sector data
            mbr_structure: Optional MBR structure for partition-specific coloring
            
        Returns:
            HTML table with color-coded MBR sections and individual partitions
        """
        if len(boot_sector) != 512:
            return '<p class="error">Invalid boot sector size</p>'
        
        # Try to parse MBR structure if not provided
        if mbr_structure is None:
            try:
                from .mbr_decoder import MBRDecoder
                decoder = MBRDecoder()
                mbr_structure = decoder.parse_mbr(boot_sector)
            except Exception as e:
                logger.debug(f"Could not parse MBR for partition coloring: {e}")
        
        # Create table header
        html_lines = ['<table class="hexdump-table">']
        
        # Header row with fixed widths (handled by CSS)
        header_cells = ['<th class="offset">Offset</th>']
        for i in range(16):
            header_cells.append(f'<th>{i:02X}</th>')
        header_cells.append('<th class="ascii">ASCII</th>')
        html_lines.append(f'<tr>{"".join(header_cells)}</tr>')
        
        # Data rows
        for offset in range(0, len(boot_sector), 16):
            row_data = boot_sector[offset:offset + 16]
            
            # Offset cell
            cells = [f'<td class="offset">0x{offset:04X}</td>']
            
            # Hex byte cells with MBR section and partition-specific coloring
            for i, byte_val in enumerate(row_data):
                byte_offset = offset + i
                css_class = self._get_mbr_section_class(byte_offset, mbr_structure)
                cells.append(f'<td class="{css_class}">{byte_val:02X}</td>')
            
            # Pad incomplete rows
            for i in range(len(row_data), 16):
                cells.append('<td></td>')
            
            # ASCII cell
            ascii_repr = ''.join(
                chr(b) if 32 <= b <= 126 else '.' for b in row_data
            )
            cells.append(f'<td class="ascii">{html_escape(ascii_repr)}</td>')
            
            html_lines.append(f'<tr>{"".join(cells)}</tr>')
        
        html_lines.append('</table>')
        
        # Add legend with partition-specific colors
        legend = self._generate_hexdump_legend(mbr_structure)
        
        return ''.join(html_lines) + legend
    
    def _generate_hexdump_legend(self, mbr_structure=None) -> str:
        """
        Generate HTML legend for hexdump with partition-specific colors.
        
        Args:
            mbr_structure: Optional MBR structure for partition-specific legend
            
        Returns:
            HTML legend string
        """
        legend_lines = [
            '<div class="mbr-legend" style="margin-top: 15px;">',
            '<h4>MBR Section Legend:</h4>',
            '<ul style="list-style: none; padding: 0;">'
        ]
        
        # Standard MBR sections
        legend_lines.append('<li><span class="mbr-boot-code" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Boot Code (0x0000-0x01BD)</li>')
        legend_lines.append('<li><span class="mbr-disk-signature" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Disk Signature (0x01B8-0x01BB)</li>')
        
        # Partition-specific legend if MBR structure is available
        if mbr_structure:
            from .mbr_decoder import PartitionTypeRegistry
            registry = PartitionTypeRegistry()
            
            for i, partition in enumerate(mbr_structure.partition_entries, 1):
                if partition.is_empty:
                    status = "Empty"
                    css_class = "mbr-partition-empty"
                else:
                    part_type = registry.get_partition_type(partition.system_id)
                    status = f"Type 0x{partition.system_id:02X} ({part_type})"
                    css_class = f"mbr-partition-{i}"
                
                legend_lines.append(f'<li><span class="{css_class}" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Partition {i}: {status}</li>')
        else:
            # Fallback to generic partition table
            legend_lines.append('<li><span class="mbr-partition-table" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Partition Table (0x01BE-0x01FD)</li>')
        
        legend_lines.append('<li><span class="mbr-boot-signature" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Boot Signature (0x01FE-0x01FF)</li>')
        legend_lines.extend(['</ul>', '</div>'])
        
        return ''.join(legend_lines)
    
    def _get_mbr_section_class(self, offset: int, mbr_structure=None) -> str:
        """
        Get CSS class for MBR section based on byte offset.
        Supports individual partition coloring when MBR structure is provided.
        
        Args:
            offset: Byte offset in boot sector
            mbr_structure: Optional MBR structure for partition-specific coloring
            
        Returns:
            CSS class name for the section
        """
        if 0 <= offset <= 0x01BD:  # Boot code (0-445)
            return "mbr-boot-code"
        elif 0x01B8 <= offset <= 0x01BB:  # Disk signature (440-443)
            return "mbr-disk-signature"
        elif 0x01BE <= offset <= 0x01FD:  # Partition table (446-509)
            if mbr_structure:
                # Use partition-specific coloring
                partition_offset = offset - 0x01BE  # 446 in decimal
                partition_number = (partition_offset // 16) + 1
                
                # Check if partition is empty
                if partition_number <= len(mbr_structure.partition_entries):
                    partition_entry = mbr_structure.partition_entries[partition_number - 1]
                    if partition_entry.is_empty:
                        return "mbr-partition-empty"
                
                return f"mbr-partition-{partition_number}"
            else:
                # Fallback to generic partition table class
                return "mbr-partition-table"
        elif 0x01FE <= offset <= 0x01FF:  # Boot signature (510-511)
            return "mbr-boot-signature"
        else:
            return ""
    
    def _generate_structure_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for structure analysis section."""
        struct_analysis = analysis_result.structure_analysis
        
        html = f"""
        <section id="structure-analysis" class="section">
            <h2>Structure Analysis</h2>
            
            <h3>Boot Sector Structure</h3>
            <ul class="data-list">
                <li><strong>Boot Signature Valid:</strong> {'Yes' if struct_analysis.is_valid_signature else 'No'}</li>
                <li><strong>Partition Count:</strong> {struct_analysis.partition_count}</li>
        """
        
        if struct_analysis.mbr_structure.disk_signature:
            html += f'<li><strong>Disk Signature:</strong> <span class="monospace">0x{struct_analysis.mbr_structure.disk_signature:08X}</span></li>'
        
        html += '</ul>'
        
        if struct_analysis.anomalies:
            html += '<h3>Structural Anomalies</h3><ul class="data-list">'
            for anomaly in struct_analysis.anomalies:
                html += f'<li><strong>{html_escape(anomaly.type)}:</strong> {html_escape(anomaly.description)} (Severity: {html_escape(anomaly.severity)})</li>'
            html += '</ul>'
        
        html += '</section>'
        return html
    
    def _generate_content_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for content analysis section."""
        content_analysis = analysis_result.content_analysis
        
        html = f"""
        <section id="content-analysis" class="section">
            <h2>Content Analysis</h2>
            
            <h3>Cryptographic Hashes</h3>
            <ul class="data-list">
        """
        
        for hash_type, hash_value in content_analysis.hashes.items():
            html += f'<li><strong>{hash_type.upper()}:</strong> <span class="hash-value">{hash_value}</span></li>'
        
        html += f"""
            </ul>
            
            <h3>Content Properties</h3>
            <ul class="data-list">
                <li><strong>Entropy:</strong> {content_analysis.entropy:.2f}</li>
            </ul>
        """
        
        if content_analysis.strings:
            html += '<h3>Extracted Strings</h3><ul class="data-list">'
            for string in content_analysis.strings[:10]:  # Show first 10
                html += f'<li><span class="monospace">{html_escape(string)}</span></li>'
            if len(content_analysis.strings) > 10:
                html += f'<li><em>... and {len(content_analysis.strings) - 10} more</em></li>'
            html += '</ul>'
        
        if content_analysis.urls:
            html += '<h3>URLs Found</h3><ul class="data-list">'
            for url in content_analysis.urls:
                html += f'<li><span class="monospace">{html_escape(url)}</span></li>'
            html += '</ul>'
        
        if content_analysis.suspicious_patterns:
            html += '<h3>Suspicious Patterns</h3><ul class="data-list">'
            for pattern in content_analysis.suspicious_patterns:
                html += f'<li><strong>{html_escape(pattern.type)}:</strong> {html_escape(pattern.description)} at offset <span class="monospace">0x{pattern.location:04X}</span></li>'
            html += '</ul>'
        
        html += '</section>'
        return html
    
    def _generate_security_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for security analysis section."""
        security_analysis = analysis_result.security_analysis
        
        html = f"""
        <section id="security-analysis" class="section">
            <h2>Security Analysis</h2>
        """
        
        if security_analysis.detected_threats:
            html += '<h3>Detected Threats</h3>'
            for threat in security_analysis.detected_threats:
                html += f"""
                <div class="threat-item">
                    <div class="threat-name">‚ö†Ô∏è {html_escape(threat.threat_name)}</div>
                    <p><strong>Type:</strong> {html_escape(threat.threat_type)}</p>
                    <p><strong>Confidence:</strong> {threat.confidence:.1%}</p>
                    <p><strong>Source:</strong> {html_escape(threat.source)}</p>
                </div>
                """
        
        if security_analysis.bootkit_indicators:
            html += '<h3>Bootkit Indicators</h3><ul class="data-list">'
            for indicator in security_analysis.bootkit_indicators:
                html += f'<li><strong>{html_escape(indicator.indicator_type)}:</strong> {html_escape(indicator.description)} (Confidence: {indicator.confidence:.1%})</li>'
            html += '</ul>'
        
        html += '</section>'
        return html
    
    def _generate_threat_intelligence_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for threat intelligence section with enhanced VirusTotal display."""
        has_main_threat_intel = (analysis_result.threat_intelligence and 
                                analysis_result.threat_intelligence.virustotal_result)
        has_boot_code_threat_intel = (analysis_result.boot_code_threat_intelligence and 
                                     analysis_result.boot_code_threat_intelligence.virustotal_result)
        
        if not has_main_threat_intel and not has_boot_code_threat_intel:
            return """
            <section id="threat-intelligence" class="section">
                <h2>Threat Intelligence</h2>
                <p>No threat intelligence data available.</p>
            </section>
            """
        
        html = '<section id="threat-intelligence" class="section">\n<h2>Threat Intelligence</h2>\n'
        
        # Generate main threat intelligence section
        if has_main_threat_intel:
            try:
                vt_result = analysis_result.threat_intelligence.virustotal_result
                analysis_type = getattr(analysis_result.threat_intelligence, 'analysis_type', 'full_boot_sector')
                analysis_label = "Boot Code Only" if analysis_type == "boot_code_only" else "Full Boot Sector"
                main_html = self._generate_virustotal_subsection_html(vt_result, analysis_label)
                html += main_html
            except Exception as e:
                import traceback
                traceback.print_exc()
        
        # Generate boot code threat intelligence section
        if has_boot_code_threat_intel:
            try:
                boot_vt_result = analysis_result.boot_code_threat_intelligence.virustotal_result
                boot_analysis_type = getattr(analysis_result.boot_code_threat_intelligence, 'analysis_type', 'boot_code_only')
                boot_analysis_label = "Boot Code Only" if boot_analysis_type == "boot_code_only" else "Boot Code Analysis"
                boot_html = self._generate_virustotal_subsection_html(boot_vt_result, boot_analysis_label, section_title="Boot Code VirusTotal Analysis")
                html += boot_html
            except Exception as e:
                import traceback
                traceback.print_exc()
        
        html += '</section>'
        return html
    
    def _generate_virustotal_subsection_html(self, vt_result, analysis_label: str, section_title: str = None) -> str:
        """Generate HTML for a VirusTotal subsection with enhanced negative result display."""
        if section_title is None:
            section_title = f"VirusTotal Results ({analysis_label})"
        else:
            section_title = f"{section_title} ({analysis_label})"
        
        # Determine detection ratio color and status
        detection_ratio = 0
        ratio_color = "green"
        ratio_class = "detection-ratio-low"
        status_indicator = "‚úÖ CLEAN"
        status_class = "clean-status"
        
        if vt_result.total_engines > 0:
            detection_ratio = vt_result.detection_count / vt_result.total_engines
            if detection_ratio == 0:
                ratio_color = "green"
                ratio_class = "detection-ratio-low"
                status_indicator = "‚úÖ CLEAN"
                status_class = "clean-status"
            elif detection_ratio >= 0.5:
                ratio_color = "red"
                ratio_class = "detection-ratio-high"
                status_indicator = "üö® HIGH RISK"
                status_class = "high-risk-status"
            elif detection_ratio >= 0.2:
                ratio_color = "orange"
                ratio_class = "detection-ratio-medium"
                status_indicator = "‚ö†Ô∏è MODERATE RISK"
                status_class = "moderate-risk-status"
            else:
                ratio_color = "orange"
                ratio_class = "detection-ratio-medium"
                status_indicator = "‚ö†Ô∏è LOW RISK"
                status_class = "low-risk-status"
        
        html = f"""
            <h3>{section_title}</h3>
            <div class="virustotal-summary">
                <div class="detection-summary">
                    <div class="detection-status {status_class}" style="margin-bottom: 15px; padding: 10px; border-radius: 5px; text-align: center; font-weight: bold;">
                        {status_indicator}
                    </div>
                    <span class="detection-count {ratio_class}">
                        {vt_result.detection_count}/{vt_result.total_engines}
                    </span>
                    <span class="detection-label">detections</span>
                    <span class="detection-ratio" style="color: {ratio_color};">
                        ({detection_ratio:.1%})
                    </span>
        """
        
        # Add explicit negative result messaging
        if vt_result.detection_count == 0:
            html += f"""
                    <div class="negative-result-message" style="margin-top: 15px; padding: 10px; background-color: #d4edda; border: 1px solid #c3e6cb; border-radius: 5px; color: #155724;">
                        <strong>No threats detected:</strong> All {vt_result.total_engines} security engines reported this as clean.
                    </div>
            """
        
        html += """
                </div>
        """
        
        # Add scan statistics if available - always show for both positive and negative results
        if vt_result.stats:
            stats = vt_result.stats
            html += f"""
                <div class="scan-statistics">
                    <h4>Scan Statistics</h4>
                    <div class="stats-grid">
                        <div class="stat-item malicious">
                            <span class="stat-label">Malicious:</span>
                            <span class="stat-value">{stats.malicious}</span>
                        </div>
                        <div class="stat-item suspicious">
                            <span class="stat-label">Suspicious:</span>
                            <span class="stat-value">{stats.suspicious}</span>
                        </div>
                        <div class="stat-item undetected">
                            <span class="stat-label">Undetected:</span>
                            <span class="stat-value">{stats.undetected}</span>
                        </div>
                        <div class="stat-item harmless">
                            <span class="stat-label">Harmless:</span>
                            <span class="stat-value">{stats.harmless}</span>
                        </div>
            """
            
            if stats.timeout > 0 or stats.failure > 0:
                html += f"""
                        <div class="stat-item timeout">
                            <span class="stat-label">Timeout:</span>
                            <span class="stat-value">{stats.timeout}</span>
                        </div>
                        <div class="stat-item failure">
                            <span class="stat-label">Failure:</span>
                            <span class="stat-value">{stats.failure}</span>
                        </div>
                """
            
            html += """
                    </div>
                </div>
            """
        
        # Add metadata - always show
        html += '<ul class="data-list">'
        
        if vt_result.scan_date:
            html += f'<li><strong>Scan Date:</strong> {vt_result.scan_date.strftime("%Y-%m-%d %H:%M:%S")}</li>'
        
        # Add additional metadata from raw response - always show when available
        if vt_result.raw_response and isinstance(vt_result.raw_response, dict):
            attributes = vt_result.raw_response.get('attributes', {})
            if attributes.get('first_submission_date'):
                from datetime import datetime
                first_submission_date = attributes['first_submission_date']
                if isinstance(first_submission_date, datetime):
                    first_seen = first_submission_date
                else:
                    first_seen = datetime.fromtimestamp(first_submission_date)
                html += f'<li><strong>First Seen:</strong> {first_seen.strftime("%Y-%m-%d %H:%M:%S")}</li>'
            if attributes.get('times_submitted'):
                html += f'<li><strong>Times Submitted:</strong> {attributes["times_submitted"]}</li>'
            if attributes.get('reputation') is not None:
                reputation = attributes['reputation']
                rep_color = "green" if reputation > 0 else "red" if reputation < 0 else "gray"
                html += f'<li><strong>Reputation Score:</strong> <span style="color: {rep_color};">{reputation}</span></li>'
        
        if vt_result.permalink:
            html += f'<li><strong>Report URL:</strong> <a href="{html_escape(vt_result.permalink)}" target="_blank">View Full Report</a></li>'
        
        html += '</ul></div>'
        
        # Add detection details - enhanced for both positive and negative results
        if vt_result.detection_count > 0:
            html += '<div class="detection-details">'
            
            # Create expandable section for detailed results
            html += '''
            <details class="detection-details-expandable">
                <summary><h4>Detection Details</h4></summary>
                <div class="engine-results">
            '''
            
            # Use enhanced engine results if available
            if vt_result.engine_results:
                detected_engines = [e for e in vt_result.engine_results if e.detected]
                
                for engine_result in detected_engines:
                    result_text = html_escape(engine_result.result or 'Detected')
                    category = engine_result.category
                    category_class = f"category-{category.lower()}"
                    
                    version_info = ""
                    if engine_result.engine_version:
                        version_info = f" <span class='engine-version'>[v{html_escape(engine_result.engine_version)}]</span>"
                    
                    html += f'''
                    <div class="engine-result {category_class}">
                        <span class="engine-name">{html_escape(engine_result.engine_name)}</span>
                        <span class="detection-result">{result_text}</span>
                        <span class="detection-category">({category})</span>
                        {version_info}
                    </div>
                    '''
            else:
                # Fall back to legacy detections
                detected_count = 0
                for engine, detection in vt_result.detections.items():
                    if detection.get("detected") and detected_count < 20:  # Limit display
                        result_text = html_escape(detection.get("result", "Unknown"))
                        category = detection.get("category", "unknown")
                        category_class = f"category-{category.lower()}"
                        
                        html += f'''
                        <div class="engine-result {category_class}">
                            <span class="engine-name">{html_escape(engine)}</span>
                            <span class="detection-result">{result_text}</span>
                            <span class="detection-category">({category})</span>
                        </div>
                        '''
                        detected_count += 1
                
                if len([d for d in vt_result.detections.values() if d.get("detected")]) > 20:
                    html += '<div class="more-results">... and more detections</div>'
            
            html += '''
                </div>
            </details>
            </div>
            '''
        else:
            # Enhanced negative result display with expandable detailed scan statistics
            html += '''
            <div class="detection-details">
                <details class="detection-details-expandable" style="border: 1px solid #c3e6cb; background-color: #f8fff9;">
                    <summary style="background-color: #d4edda; color: #155724;"><h4>‚úÖ Clean Scan Details</h4></summary>
                    <div class="engine-results" style="background-color: #f8fff9;">
            '''
            
            # Show clean engines if engine results are available
            if vt_result.engine_results:
                clean_engines = [e for e in vt_result.engine_results if not e.detected]
                
                if clean_engines:
                    html += f'<div style="padding: 15px; color: #155724;"><strong>All {len(clean_engines)} engines reported clean:</strong></div>'
                    
                    # Show first 10 clean engines as examples
                    for i, engine_result in enumerate(clean_engines[:10]):
                        category = engine_result.category or "undetected"
                        category_class = f"category-{category.lower()}"
                        
                        version_info = ""
                        if engine_result.engine_version:
                            version_info = f" <span class='engine-version'>[v{html_escape(engine_result.engine_version)}]</span>"
                        
                        html += f'''
                        <div class="engine-result {category_class}" style="background-color: #d4edda; border-left-color: #28a745;">
                            <span class="engine-name">{html_escape(engine_result.engine_name)}</span>
                            <span class="detection-result">Clean</span>
                            <span class="detection-category">({category})</span>
                            {version_info}
                        </div>
                        '''
                    
                    if len(clean_engines) > 10:
                        html += f'<div class="more-results" style="color: #155724;">... and {len(clean_engines) - 10} more engines reported clean</div>'
            else:
                # Fallback message for negative results
                html += f'''
                <div style="padding: 15px; color: #155724; text-align: center;">
                    <strong>All {vt_result.total_engines} security engines reported this file as clean.</strong>
                    <br>No malicious behavior or suspicious patterns detected.
                </div>
                '''
            
            html += '''
                </div>
            </details>
            </div>
            '''
        
        html += '</div>'
        return html
    
    def _generate_vbr_analysis_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for VBR analysis section."""
        if not analysis_result.vbr_analysis:
            return """
            <section id="vbr-analysis" class="section">
                <h2>Volume Boot Record (VBR) Analysis</h2>
                <p>No VBR analysis performed (image file analysis or no valid partitions found).</p>
            </section>
            """
        
        html = f"""
        <section id="vbr-analysis" class="section">
            <h2>Volume Boot Record (VBR) Analysis</h2>
            <p>Analyzed {len(analysis_result.vbr_analysis)} partition(s) for VBR data:</p>
        """
        
        for vbr_result in analysis_result.vbr_analysis:
            partition_num = vbr_result.partition_number
            partition = vbr_result.partition_info
            
            html += f"""
            <div class="vbr-partition" style="margin-bottom: 30px; border: 1px solid #dee2e6; border-radius: 5px; padding: 20px;">
                <h3>Partition {partition_num}</h3>
                
                <h4>Partition Information</h4>
                <ul class="data-list">
                    <li><strong>System ID:</strong> <span class="monospace">0x{partition.partition_type:02X}</span></li>
                    <li><strong>Start LBA:</strong> {partition.start_lba}</li>
                    <li><strong>Size:</strong> {partition.size_sectors} sectors</li>
                    <li><strong>Bootable:</strong> {'Yes' if partition.status & 0x80 else 'No'}</li>
                </ul>
            """
            
            if vbr_result.extraction_error:
                html += f"""
                <div class="threat-item">
                    <h4>VBR Extraction Failed</h4>
                    <p><strong>Error:</strong> {html_escape(vbr_result.extraction_error)}</p>
                </div>
                """
            
            # Show VBR structure if available (regardless of extraction error)
            if vbr_result.vbr_structure:
                vbr = vbr_result.vbr_structure
                html += f"""
                <h4>VBR Structure</h4>
                <ul class="data-list">
                    <li><strong>Filesystem:</strong> {html_escape(vbr.filesystem_type.value)}</li>
                    <li><strong>Boot Signature:</strong> <span class="monospace">0x{vbr.boot_signature:04X}</span></li>
                """
                
                # Filesystem metadata
                metadata = vbr.filesystem_metadata
                if metadata.volume_label:
                    html += f'<li><strong>Volume Label:</strong> {html_escape(metadata.volume_label)}</li>'
                if metadata.cluster_size:
                    html += f'<li><strong>Cluster Size:</strong> {metadata.cluster_size} bytes</li>'
                if metadata.total_sectors:
                    html += f'<li><strong>Total Sectors:</strong> {metadata.total_sectors}</li>'
                if metadata.filesystem_version:
                    html += f'<li><strong>Filesystem Version:</strong> {html_escape(metadata.filesystem_version)}</li>'
                
                html += '</ul>'
            
            # Show VBR content analysis if available (regardless of extraction error)
            if vbr_result.content_analysis:
                    content = vbr_result.content_analysis
                    
                    # VBR hashes
                    html += '<h4>VBR Content Analysis</h4>'
                    html += '<h5>Cryptographic Hashes</h5><ul class="data-list">'
                    for hash_type, hash_value in content.hashes.items():
                        html += f'<li><strong>{hash_type.upper()}:</strong> <span class="hash-value">{hash_value}</span></li>'
                    html += '</ul>'
                    
                    # Boot code hashes if different
                    if content.boot_code_hashes:
                        html += '<h5>Boot Code Hashes</h5><ul class="data-list">'
                        for hash_type, hash_value in content.boot_code_hashes.items():
                            html += f'<li><strong>{hash_type.upper()}:</strong> <span class="hash-value">{hash_value}</span></li>'
                        html += '</ul>'
                    
                    # Threat level
                    threat_badge = self.format_threat_level_badge(content.threat_level)
                    html += f'<h5>VBR Threat Assessment</h5><div style="text-align: center;">{threat_badge}</div>'
                    
                    # Boot patterns
                    if content.detected_patterns:
                        html += '<h5>Detected Boot Patterns</h5><ul class="data-list">'
                        for pattern in content.detected_patterns:
                            html += f'<li><strong>{html_escape(pattern.pattern_type)}:</strong> {html_escape(pattern.description)}'
                            if pattern.significance:
                                html += f' <em>({html_escape(pattern.significance)})</em>'
                            html += '</li>'
                        html += '</ul>'
                    
                    # Anomalies
                    if content.anomalies:
                        html += '<h5>Detected Anomalies</h5>'
                        for anomaly in content.anomalies:
                            severity_class = "threat-item" if anomaly.severity in ["high", "critical"] else ""
                            html += f"""
                            <div class="{severity_class}" style="margin-bottom: 10px;">
                                <strong>{html_escape(anomaly.anomaly_type)}:</strong> {html_escape(anomaly.description)}
                                <br><strong>Severity:</strong> {html_escape(anomaly.severity).upper()}
                            """
                            if anomaly.evidence:
                                html += '<br><strong>Evidence:</strong><ul>'
                                for evidence in anomaly.evidence:
                                    html += f'<li>{html_escape(evidence)}</li>'
                                html += '</ul>'
                            html += '</div>'
                    
                    # VBR disassembly
                    if content.disassembly_result and content.disassembly_result.instructions:
                        html += '<h5>VBR Boot Code Disassembly</h5>'
                        vbr_assembly_html = self.format_assembly_syntax_highlighting(content.disassembly_result)
                        html += vbr_assembly_html
            
            # VBR hexdump (show if VBR structure is available, regardless of extraction error)
            if vbr_result.vbr_structure and vbr_result.vbr_structure.raw_data:
                html += '<h5>VBR Hexdump</h5>'
                vbr_hexdump_html = self._format_vbr_hexdump_html(vbr_result.vbr_structure.raw_data)
                html += vbr_hexdump_html
            
            html += '</div>'  # Close vbr-partition div
        
        html += '</section>'
        return html
    
    def _format_vbr_hexdump_html(self, vbr_data: bytes) -> str:
        """
        Format VBR data as HTML hexdump table.
        
        Args:
            vbr_data: 512-byte VBR data
            
        Returns:
            HTML table with VBR hexdump
        """
        if len(vbr_data) != 512:
            return f'<p class="error">Invalid VBR size: {len(vbr_data)} bytes (expected 512)</p>'
        
        # Create table header
        html_lines = ['<table class="hexdump-table" style="margin-top: 10px;">']
        
        # Header row
        header_cells = ['<th class="offset">Offset</th>']
        for i in range(16):
            header_cells.append(f'<th>{i:02X}</th>')
        header_cells.append('<th class="ascii">ASCII</th>')
        html_lines.append(f'<tr>{"".join(header_cells)}</tr>')
        
        # Data rows
        for offset in range(0, len(vbr_data), 16):
            row_data = vbr_data[offset:offset + 16]
            
            # Offset cell
            cells = [f'<td class="offset">0x{offset:04X}</td>']
            
            # Hex byte cells
            for byte_val in row_data:
                cells.append(f'<td>{byte_val:02X}</td>')
            
            # Pad incomplete rows
            for i in range(len(row_data), 16):
                cells.append('<td></td>')
            
            # ASCII cell
            ascii_repr = ''.join(
                chr(b) if 32 <= b <= 126 else '.' for b in row_data
            )
            cells.append(f'<td class="ascii">{html_escape(ascii_repr)}</td>')
            
            html_lines.append(f'<tr>{"".join(cells)}</tr>')
        
        html_lines.append('</table>')
        return ''.join(html_lines)
    
    def _generate_disassembly_section_html(self, assembly_html: str) -> str:
        """Generate HTML for disassembly section."""
        return f"""
        <section id="disassembly" class="section">
            <h2>Boot Code Disassembly</h2>
            <p>x86 assembly instructions from the boot code region:</p>
            {assembly_html}
        </section>
        """
    
    def _generate_hexdump_section_html(self, hexdump_html: str) -> str:
        """Generate HTML for hexdump section."""
        return f"""
        <section id="hexdump" class="section">
            <h2>Hexdump</h2>
            <p>Raw boot sector data with MBR section highlighting:</p>
            {hexdump_html}
        </section>
        """
    
    def _generate_summary_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for summary section."""
        threat_level = analysis_result.security_analysis.threat_level
        
        if threat_level in [ThreatLevel.HIGH, ThreatLevel.CRITICAL]:
            summary_class = "threat-item"
            summary_text = """
            <h3>‚ö†Ô∏è CRITICAL FINDINGS DETECTED!</h3>
            <p>This boot sector shows signs of malicious activity. Immediate investigation and remediation recommended.</p>
            """
        elif threat_level == ThreatLevel.MEDIUM:
            summary_class = "threat-item"
            summary_text = """
            <h3>‚ö†Ô∏è Suspicious Activity Detected</h3>
            <p>Further investigation recommended.</p>
            """
        else:
            summary_class = ""
            summary_text = """
            <h3>‚úÖ No Significant Threats Detected</h3>
            <p>Boot sector appears to be clean.</p>
            """
        
        return f"""
        <section id="summary" class="section">
            <h2>Summary</h2>
            <div class="{summary_class}">
                {summary_text}
            </div>
        </section>
        """