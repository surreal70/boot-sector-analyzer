"""HTML report generation for boot sector analysis results."""

from html import escape as html_escape
from datetime import datetime
from typing import List, Dict, Any

from . import __version__
from .models import AnalysisResult, ThreatLevel, DisassemblyResult, Instruction


class HTMLGenerator:
    """Generates HTML reports with embedded CSS styling and interactive elements."""
    
    def __init__(self):
        """Initialize HTML generator."""
        pass
    
    def create_html_document(self, analysis_result: AnalysisResult) -> str:
        """
        Create complete HTML document with DOCTYPE and metadata.
        
        Args:
            analysis_result: Complete analysis results
            
        Returns:
            Self-contained HTML document string
        """
        # Generate HTML content sections
        css_styles = self.embed_css_styles()
        threat_badge = self.format_threat_level_badge(analysis_result.security_analysis.threat_level)
        table_of_contents = self.create_table_of_contents()
        
        # Format disassembly if available
        assembly_html = ""
        if analysis_result.disassembly:
            assembly_html = self.format_assembly_syntax_highlighting(analysis_result.disassembly)
        
        # Format hexdump with colors
        hexdump_html = self.format_hexdump_with_colors(analysis_result.hexdump.raw_data)
        
        # Get current timestamp and version
        generation_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        analyzer_version = f"v{__version__}"  # Current version
        
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Boot Sector Analyzer {analyzer_version}">
    <meta name="generated" content="{generation_time}">
    <title>Boot Sector Analysis Report - {html_escape(analysis_result.source)}</title>
    <style>
{css_styles}
    </style>
</head>
<body>
    <div class="container">
        <header class="report-header">
            <h1>Boot Sector Analysis Report</h1>
            <div class="report-meta">
                <p><strong>Source:</strong> {html_escape(analysis_result.source)}</p>
                <p><strong>Analysis Time:</strong> {analysis_result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p><strong>Generated:</strong> {generation_time}</p>
                <p><strong>Analyzer Version:</strong> {analyzer_version}</p>
            </div>
            <div class="threat-level">
                {threat_badge}
            </div>
        </header>
        
        {table_of_contents}
        
        <main class="report-content">
            {self._generate_structure_section_html(analysis_result)}
            {self._generate_content_section_html(analysis_result)}
            {self._generate_security_section_html(analysis_result)}
            {self._generate_threat_intelligence_section_html(analysis_result)}
            {self._generate_disassembly_section_html(assembly_html)}
            {self._generate_hexdump_section_html(hexdump_html)}
            {self._generate_summary_section_html(analysis_result)}
        </main>
        
        <footer class="report-footer">
            <p>Generated by Boot Sector Analyzer {analyzer_version} on {generation_time}</p>
        </footer>
    </div>
</body>
</html>"""
        
        return html_content
    
    def embed_css_styles(self) -> str:
        """
        Generate embedded CSS for styling and responsive design.
        
        Returns:
            CSS styles as string
        """
        return """
/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    min-height: 100vh;
}

/* Header styles */
.report-header {
    border-bottom: 3px solid #007acc;
    padding-bottom: 20px;
    margin-bottom: 30px;
}

.report-header h1 {
    color: #007acc;
    font-size: 2.5em;
    margin-bottom: 15px;
}

.report-meta {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 15px;
}

.report-meta p {
    margin-bottom: 5px;
}

/* Threat level badges */
.threat-level {
    text-align: center;
    margin: 20px 0;
}

.threat-badge {
    display: inline-block;
    padding: 10px 20px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 1.2em;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.threat-low {
    background-color: #28a745;
    color: white;
}

.threat-medium {
    background-color: #ffc107;
    color: #212529;
}

.threat-high {
    background-color: #dc3545;
    color: white;
}

.threat-critical {
    background-color: #6f0000;
    color: white;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

/* Table of contents */
.table-of-contents {
    background-color: #e9ecef;
    padding: 20px;
    border-radius: 5px;
    margin-bottom: 30px;
}

.table-of-contents h2 {
    margin-bottom: 15px;
    color: #495057;
}

.toc-list {
    list-style: none;
    columns: 2;
    column-gap: 30px;
}

.toc-list li {
    margin-bottom: 8px;
    break-inside: avoid;
}

.toc-list a {
    color: #007acc;
    text-decoration: none;
    padding: 5px 10px;
    display: block;
    border-radius: 3px;
    transition: background-color 0.2s;
}

.toc-list a:hover {
    background-color: #007acc;
    color: white;
}

/* Section styles */
.section {
    margin-bottom: 40px;
    padding: 20px;
    border: 1px solid #dee2e6;
    border-radius: 5px;
    background-color: #fff;
}

.section h2 {
    color: #007acc;
    border-bottom: 2px solid #007acc;
    padding-bottom: 10px;
    margin-bottom: 20px;
}

.section h3 {
    color: #495057;
    margin-top: 20px;
    margin-bottom: 10px;
}

/* Monospace formatting for technical data */
.monospace {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #f8f9fa;
    padding: 2px 4px;
    border-radius: 3px;
    font-size: 0.9em;
}

.code-block {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 5px;
    padding: 15px;
    overflow-x: auto;
    white-space: pre;
    line-height: 1.4;
}

/* Hash values - copyable */
.hash-value {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #f8f9fa;
    padding: 5px 8px;
    border-radius: 3px;
    border: 1px solid #dee2e6;
    cursor: text;
    user-select: all;
    word-break: break-all;
}

/* Assembly syntax highlighting */
.assembly-code {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    background-color: #1e1e1e;
    color: #d4d4d4;
    padding: 20px;
    border-radius: 5px;
    overflow-x: auto;
    line-height: 1.4;
}

.asm-instruction {
    color: #569cd6; /* Blue for instructions */
}

.asm-register {
    color: #4ec9b0; /* Green for registers */
}

.asm-immediate {
    color: #ce9178; /* Orange for immediate values */
}

.asm-address {
    color: #f44747; /* Red for memory addresses */
}

.asm-comment {
    color: #6a9955; /* Green for comments */
    font-style: italic;
}

/* Hexdump table */
.hexdump-table {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    border-collapse: collapse;
    width: 100%;
    font-size: 0.85em;
    background-color: #fff;
}

.hexdump-table th,
.hexdump-table td {
    padding: 4px 6px;
    text-align: center;
    border: 1px solid #dee2e6;
}

.hexdump-table th {
    background-color: #495057;
    color: white;
    font-weight: bold;
}

.hexdump-table .offset {
    background-color: #f8f9fa;
    font-weight: bold;
    text-align: right;
}

.hexdump-table .ascii {
    text-align: left;
    background-color: #f8f9fa;
}

/* MBR section highlighting */
.mbr-boot-code {
    background-color: #cce5ff !important; /* Light blue */
}

.mbr-disk-signature {
    background-color: #fff2cc !important; /* Light yellow */
}

.mbr-partition-table {
    background-color: #d4edda !important; /* Light green */
}

.mbr-boot-signature {
    background-color: #f8d7da !important; /* Light red */
}

/* Lists and data display */
.data-list {
    list-style: none;
    padding-left: 0;
}

.data-list li {
    padding: 8px 0;
    border-bottom: 1px solid #e9ecef;
}

.data-list li:last-child {
    border-bottom: none;
}

.threat-item {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 10px;
}

.threat-item .threat-name {
    font-weight: bold;
    color: #721c24;
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        padding: 10px;
    }
    
    .report-header h1 {
        font-size: 2em;
    }
    
    .toc-list {
        columns: 1;
    }
    
    .hexdump-table {
        font-size: 0.7em;
    }
    
    .hexdump-table th,
    .hexdump-table td {
        padding: 2px 3px;
    }
}

@media (max-width: 480px) {
    .report-header h1 {
        font-size: 1.5em;
    }
    
    .threat-badge {
        font-size: 1em;
        padding: 8px 15px;
    }
    
    .section {
        padding: 15px;
    }
}

/* Print styles */
@media print {
    body {
        background-color: white;
    }
    
    .container {
        box-shadow: none;
        max-width: none;
    }
    
    .threat-critical {
        animation: none;
    }
    
    .toc-list a {
        color: #000;
    }
}
"""
    
    def format_threat_level_badge(self, threat_level: ThreatLevel) -> str:
        """
        Create color-coded threat level badge.
        
        Args:
            threat_level: Threat level to format
            
        Returns:
            HTML for threat level badge
        """
        level_classes = {
            ThreatLevel.LOW: "threat-low",
            ThreatLevel.MEDIUM: "threat-medium", 
            ThreatLevel.HIGH: "threat-high",
            ThreatLevel.CRITICAL: "threat-critical"
        }
        
        level_icons = {
            ThreatLevel.LOW: "‚úÖ",
            ThreatLevel.MEDIUM: "‚ö†Ô∏è",
            ThreatLevel.HIGH: "üö®", 
            ThreatLevel.CRITICAL: "üî¥"
        }
        
        css_class = level_classes.get(threat_level, "threat-low")
        icon = level_icons.get(threat_level, "‚ùì")
        
        return f'<div class="threat-badge {css_class}">{icon} {threat_level.value}</div>'
    
    def format_assembly_syntax_highlighting(self, disassembly: DisassemblyResult) -> str:
        """
        Apply syntax highlighting to assembly code.
        
        Args:
            disassembly: Disassembly results to format
            
        Returns:
            HTML with syntax-highlighted assembly code
        """
        if not disassembly.instructions:
            return '<p class="monospace">No assembly instructions available.</p>'
        
        html_lines = []
        
        for instruction in disassembly.instructions:
            # Format address
            addr_html = f'<span class="asm-address">{instruction.address:04X}</span>'
            
            # Format instruction bytes
            bytes_str = ' '.join(f'{b:02X}' for b in instruction.bytes)
            bytes_html = f'<span class="monospace">{bytes_str:12}</span>'
            
            # Format mnemonic (instruction)
            mnemonic_html = f'<span class="asm-instruction">{instruction.mnemonic}</span>'
            
            # Format operands with syntax highlighting
            operands_html = self._highlight_operands(instruction.operands)
            
            # Format comment if present
            comment_html = ""
            if instruction.comment:
                comment_html = f' <span class="asm-comment">; {html_escape(instruction.comment)}</span>'
            
            # Combine into line
            line = f'{addr_html}:  {bytes_html}  {mnemonic_html} {operands_html}{comment_html}'
            html_lines.append(line)
        
        # Add invalid instructions if any
        for invalid in disassembly.invalid_instructions:
            addr_html = f'<span class="asm-address">{invalid.address:04X}</span>'
            bytes_str = ' '.join(f'{b:02X}' for b in invalid.bytes)
            bytes_html = f'<span class="monospace">{bytes_str:12}</span>'
            reason_html = f'<span class="asm-comment">; Invalid: {html_escape(invalid.reason)}</span>'
            
            line = f'{addr_html}:  {bytes_html}  {reason_html}'
            html_lines.append(line)
        
        return f'<div class="assembly-code">{"<br>".join(html_lines)}</div>'
    
    def _highlight_operands(self, operands: str) -> str:
        """
        Apply syntax highlighting to instruction operands.
        
        Args:
            operands: Operand string to highlight
            
        Returns:
            HTML with highlighted operands
        """
        if not operands:
            return ""
        
        # Simple regex-based highlighting
        import re
        
        # Escape HTML first
        operands = html_escape(operands)
        
        # Highlight registers (common x86 registers)
        register_pattern = r'\b(ax|bx|cx|dx|si|di|sp|bp|al|ah|bl|bh|cl|ch|dl|dh|eax|ebx|ecx|edx|esi|edi|esp|ebp|cs|ds|es|fs|gs|ss)\b'
        operands = re.sub(register_pattern, r'<span class="asm-register">\1</span>', operands, flags=re.IGNORECASE)
        
        # Highlight immediate values (hex numbers)
        immediate_pattern = r'\b0x[0-9a-fA-F]+\b|\b[0-9]+h?\b'
        operands = re.sub(immediate_pattern, r'<span class="asm-immediate">\g<0></span>', operands)
        
        # Highlight memory addresses (brackets)
        address_pattern = r'\[([^\]]+)\]'
        operands = re.sub(address_pattern, r'[<span class="asm-address">\1</span>]', operands)
        
        return operands
    
    def create_table_of_contents(self) -> str:
        """
        Generate table of contents with anchor links.
        
        Returns:
            HTML for table of contents
        """
        return """
        <nav class="table-of-contents">
            <h2>Table of Contents</h2>
            <ul class="toc-list">
                <li><a href="#structure-analysis">Structure Analysis</a></li>
                <li><a href="#content-analysis">Content Analysis</a></li>
                <li><a href="#security-analysis">Security Analysis</a></li>
                <li><a href="#threat-intelligence">Threat Intelligence</a></li>
                <li><a href="#disassembly">Boot Code Disassembly</a></li>
                <li><a href="#hexdump">Hexdump</a></li>
                <li><a href="#summary">Summary</a></li>
            </ul>
        </nav>
        """
    
    def format_hexdump_with_colors(self, boot_sector: bytes) -> str:
        """
        Create color-coded hexdump table for MBR sections.
        
        Args:
            boot_sector: 512-byte boot sector data
            
        Returns:
            HTML table with color-coded MBR sections
        """
        if len(boot_sector) != 512:
            return '<p class="error">Invalid boot sector size</p>'
        
        # Create table header
        html_lines = ['<table class="hexdump-table">']
        
        # Header row
        header_cells = ['<th class="offset">Offset</th>']
        for i in range(16):
            header_cells.append(f'<th>{i:02X}</th>')
        header_cells.append('<th class="ascii">ASCII</th>')
        html_lines.append(f'<tr>{"".join(header_cells)}</tr>')
        
        # Data rows
        for offset in range(0, len(boot_sector), 16):
            row_data = boot_sector[offset:offset + 16]
            
            # Offset cell
            cells = [f'<td class="offset">0x{offset:04X}</td>']
            
            # Hex byte cells with MBR section coloring
            for i, byte_val in enumerate(row_data):
                byte_offset = offset + i
                css_class = self._get_mbr_section_class(byte_offset)
                cells.append(f'<td class="{css_class}">{byte_val:02X}</td>')
            
            # Pad incomplete rows
            for i in range(len(row_data), 16):
                cells.append('<td></td>')
            
            # ASCII cell
            ascii_repr = ''.join(
                chr(b) if 32 <= b <= 126 else '.' for b in row_data
            )
            cells.append(f'<td class="ascii">{html_escape(ascii_repr)}</td>')
            
            html_lines.append(f'<tr>{"".join(cells)}</tr>')
        
        html_lines.append('</table>')
        
        # Add legend
        legend = """
        <div class="mbr-legend" style="margin-top: 15px;">
            <h4>MBR Section Legend:</h4>
            <ul style="list-style: none; padding: 0;">
                <li><span class="mbr-boot-code" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Boot Code (0x0000-0x01BD)</li>
                <li><span class="mbr-disk-signature" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Disk Signature (0x01B8-0x01BB)</li>
                <li><span class="mbr-partition-table" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Partition Table (0x01BE-0x01FD)</li>
                <li><span class="mbr-boot-signature" style="padding: 2px 8px; margin-right: 10px;">‚ñ†</span> Boot Signature (0x01FE-0x01FF)</li>
            </ul>
        </div>
        """
        
        return ''.join(html_lines) + legend
    
    def _get_mbr_section_class(self, offset: int) -> str:
        """
        Get CSS class for MBR section based on byte offset.
        
        Args:
            offset: Byte offset in boot sector
            
        Returns:
            CSS class name for the section
        """
        if 0 <= offset <= 0x01BD:  # Boot code (0-445)
            return "mbr-boot-code"
        elif 0x01B8 <= offset <= 0x01BB:  # Disk signature (440-443)
            return "mbr-disk-signature"
        elif 0x01BE <= offset <= 0x01FD:  # Partition table (446-509)
            return "mbr-partition-table"
        elif 0x01FE <= offset <= 0x01FF:  # Boot signature (510-511)
            return "mbr-boot-signature"
        else:
            return ""
    
    def _generate_structure_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for structure analysis section."""
        struct_analysis = analysis_result.structure_analysis
        
        html = f"""
        <section id="structure-analysis" class="section">
            <h2>Structure Analysis</h2>
            
            <h3>Boot Sector Structure</h3>
            <ul class="data-list">
                <li><strong>Boot Signature Valid:</strong> {'Yes' if struct_analysis.is_valid_signature else 'No'}</li>
                <li><strong>Partition Count:</strong> {struct_analysis.partition_count}</li>
        """
        
        if struct_analysis.mbr_structure.disk_signature:
            html += f'<li><strong>Disk Signature:</strong> <span class="monospace">0x{struct_analysis.mbr_structure.disk_signature:08X}</span></li>'
        
        html += '</ul>'
        
        if struct_analysis.anomalies:
            html += '<h3>Structural Anomalies</h3><ul class="data-list">'
            for anomaly in struct_analysis.anomalies:
                html += f'<li><strong>{html_escape(anomaly.type)}:</strong> {html_escape(anomaly.description)} (Severity: {html_escape(anomaly.severity)})</li>'
            html += '</ul>'
        
        html += '</section>'
        return html
    
    def _generate_content_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for content analysis section."""
        content_analysis = analysis_result.content_analysis
        
        html = f"""
        <section id="content-analysis" class="section">
            <h2>Content Analysis</h2>
            
            <h3>Cryptographic Hashes</h3>
            <ul class="data-list">
        """
        
        for hash_type, hash_value in content_analysis.hashes.items():
            html += f'<li><strong>{hash_type.upper()}:</strong> <span class="hash-value">{hash_value}</span></li>'
        
        html += f"""
            </ul>
            
            <h3>Content Properties</h3>
            <ul class="data-list">
                <li><strong>Entropy:</strong> {content_analysis.entropy:.2f}</li>
            </ul>
        """
        
        if content_analysis.strings:
            html += '<h3>Extracted Strings</h3><ul class="data-list">'
            for string in content_analysis.strings[:10]:  # Show first 10
                html += f'<li><span class="monospace">{html_escape(string)}</span></li>'
            if len(content_analysis.strings) > 10:
                html += f'<li><em>... and {len(content_analysis.strings) - 10} more</em></li>'
            html += '</ul>'
        
        if content_analysis.urls:
            html += '<h3>URLs Found</h3><ul class="data-list">'
            for url in content_analysis.urls:
                html += f'<li><span class="monospace">{html_escape(url)}</span></li>'
            html += '</ul>'
        
        if content_analysis.suspicious_patterns:
            html += '<h3>Suspicious Patterns</h3><ul class="data-list">'
            for pattern in content_analysis.suspicious_patterns:
                html += f'<li><strong>{html_escape(pattern.type)}:</strong> {html_escape(pattern.description)} at offset <span class="monospace">0x{pattern.location:04X}</span></li>'
            html += '</ul>'
        
        html += '</section>'
        return html
    
    def _generate_security_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for security analysis section."""
        security_analysis = analysis_result.security_analysis
        
        html = f"""
        <section id="security-analysis" class="section">
            <h2>Security Analysis</h2>
        """
        
        if security_analysis.detected_threats:
            html += '<h3>Detected Threats</h3>'
            for threat in security_analysis.detected_threats:
                html += f"""
                <div class="threat-item">
                    <div class="threat-name">‚ö†Ô∏è {html_escape(threat.threat_name)}</div>
                    <p><strong>Type:</strong> {html_escape(threat.threat_type)}</p>
                    <p><strong>Confidence:</strong> {threat.confidence:.1%}</p>
                    <p><strong>Source:</strong> {html_escape(threat.source)}</p>
                </div>
                """
        
        if security_analysis.bootkit_indicators:
            html += '<h3>Bootkit Indicators</h3><ul class="data-list">'
            for indicator in security_analysis.bootkit_indicators:
                html += f'<li><strong>{html_escape(indicator.indicator_type)}:</strong> {html_escape(indicator.description)} (Confidence: {indicator.confidence:.1%})</li>'
            html += '</ul>'
        
        html += '</section>'
        return html
    
    def _generate_threat_intelligence_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for threat intelligence section."""
        if not analysis_result.threat_intelligence or not analysis_result.threat_intelligence.virustotal_result:
            return """
            <section id="threat-intelligence" class="section">
                <h2>Threat Intelligence</h2>
                <p>No threat intelligence data available.</p>
            </section>
            """
        
        vt_result = analysis_result.threat_intelligence.virustotal_result
        
        html = f"""
        <section id="threat-intelligence" class="section">
            <h2>Threat Intelligence</h2>
            
            <h3>VirusTotal Results</h3>
            <ul class="data-list">
                <li><strong>Detections:</strong> {vt_result.detection_count}/{vt_result.total_engines}</li>
        """
        
        if vt_result.scan_date:
            html += f'<li><strong>Scan Date:</strong> {vt_result.scan_date.strftime("%Y-%m-%d %H:%M:%S")}</li>'
        
        if vt_result.permalink:
            html += f'<li><strong>Report URL:</strong> <a href="{html_escape(vt_result.permalink)}" target="_blank">{html_escape(vt_result.permalink)}</a></li>'
        
        html += '</ul>'
        
        if vt_result.detection_count > 0:
            html += '<h3>Detection Details</h3><ul class="data-list">'
            for engine, detection in list(vt_result.detections.items())[:10]:  # Show first 10
                if detection.get("detected"):
                    result = detection.get("result", "Unknown")
                    html += f'<li><strong>{html_escape(engine)}:</strong> {html_escape(result)}</li>'
            html += '</ul>'
        
        html += '</section>'
        return html
    
    def _generate_disassembly_section_html(self, assembly_html: str) -> str:
        """Generate HTML for disassembly section."""
        return f"""
        <section id="disassembly" class="section">
            <h2>Boot Code Disassembly</h2>
            <p>x86 assembly instructions from the boot code region:</p>
            {assembly_html}
        </section>
        """
    
    def _generate_hexdump_section_html(self, hexdump_html: str) -> str:
        """Generate HTML for hexdump section."""
        return f"""
        <section id="hexdump" class="section">
            <h2>Hexdump</h2>
            <p>Raw boot sector data with MBR section highlighting:</p>
            {hexdump_html}
        </section>
        """
    
    def _generate_summary_section_html(self, analysis_result: AnalysisResult) -> str:
        """Generate HTML for summary section."""
        threat_level = analysis_result.security_analysis.threat_level
        
        if threat_level in [ThreatLevel.HIGH, ThreatLevel.CRITICAL]:
            summary_class = "threat-item"
            summary_text = """
            <h3>‚ö†Ô∏è CRITICAL FINDINGS DETECTED!</h3>
            <p>This boot sector shows signs of malicious activity. Immediate investigation and remediation recommended.</p>
            """
        elif threat_level == ThreatLevel.MEDIUM:
            summary_class = "threat-item"
            summary_text = """
            <h3>‚ö†Ô∏è Suspicious Activity Detected</h3>
            <p>Further investigation recommended.</p>
            """
        else:
            summary_class = ""
            summary_text = """
            <h3>‚úÖ No Significant Threats Detected</h3>
            <p>Boot sector appears to be clean.</p>
            """
        
        return f"""
        <section id="summary" class="section">
            <h2>Summary</h2>
            <div class="{summary_class}">
                {summary_text}
            </div>
        </section>
        """